/*! @comandeer/mocha-lib-tester v0.7.0 | (c) 2022 Comandeer | MIT license (see LICENSE) */
import t from"chalk";import e from"@comandeer/cli-spinner";import{Enumify as r}from"enumify";import s from"chokidar";import{Worker as o,spawn as n,Thread as i}from"threads";import{createCoverageMap as a}from"istanbul-lib-coverage";import{ESLint as c}from"eslint";import{resolve as u}from"path";import l from"istanbul-lib-report";import h from"istanbul-reports";import{promisify as p,format as d}from"util";import m from"glob";import f,{reporters as w}from"mocha";import{addHook as y}from"pirates";import g from"@babel/register";import b from"@babel/preset-env";import{createInstrumenter as E}from"istanbul-lib-instrument";import{get as v}from"https";import{exec as _}from"child_process";import{promises as S,createWriteStream as C}from"fs";import{pipeline as R}from"stream";import T from"is-ci";const L=Symbol("listeners"),x=Symbol("onceListeners");class j{constructor(){this[L]=new Map,this[x]=new Map}on(t,e){this._getListenersCollection(t).add(e)}once(t,e){this.on(t,e);this._getListenersCollection(t,this[x]).add(e)}off(t,e){const r=this._getListenersCollection(t),s=this._getListenersCollection(t,this[x]);r.delete(e),s.delete(e)}async emit(t,...e){const r=this._getListenersCollection(t),s=this._getListenersCollection(t,this[x]);for(const o of r)await o(...e),s.has(o)&&this.off(t,o)}_getListenersCollection(t,e=this[L]){if(e.has(t))return e.get(t);const r=new Set;return e.set(t,r),r}}const O=Symbol("steps"),P=Symbol("stepResults");class k extends j{constructor(){super(),this[O]=Object.freeze(new Set),this[P]={}}get steps(){return this[O]}addStep(t){if(!q(t,[...this.steps].map((({id:t})=>t))))throw new TypeError("Provided object must be a valid step definition");this.steps.add(t)}addSteps(t){if(!(Array.isArray(t)&&t.every((t=>q(t)))))throw new TypeError("Provided array must contain only valid step definitions");t.forEach((t=>{this.addStep(t)}))}async run(t=process.cwd()){if(!("string"==typeof(e=t)&&e.trim().length>0))throw new TypeError("Provided path must be a non-empty string");var e;await this.emit("start");const r=[...this.steps];return this._processSteps(r,t)}async _processSteps(t,e){const r=async t=>(await this.emit("end",t),t),s=t.shift(),o=this._constructContext(e);if(!s)return r(!0);await this.emit("step:start",s,o);try{const n=this._constructRequiresParameter(s),i=await s.run(e,n);if(!function(t){if(!t||"object"!=typeof t)return!1;return t.results&&"object"==typeof t.results}(i))throw new TypeError(`Step ${s.name} didn't return correct results`);if(this[P][s.id]=i,await this.emit("step:end",s,i,o),!i.ok)return r(!1);if(0===t.length)return r(!0)}catch(t){return await this.emit("error",t),r(!1)}return this._processSteps(t,e)}_constructRequiresParameter({requires:t}){return t?t.reduce(((t,e)=>({...t,...{[e]:this[P][e]}})),{}):{}}_constructContext(t){return{projectPath:t}}}function q(t,e){if(!t||"object"!=typeof t)return!1;const r=function(t){if("string"!=typeof t||0===t.trim().length)return!1;const e=t===t.toLowerCase(),r=!/\s/.test(t);return e&&r}(t.id),s="string"==typeof t.name&&t.name.trim().length>0,o="function"==typeof t.run,n="function"==typeof t.report,i=!Array.isArray(e)||function(t,e){if(void 0===t)return!0;if(void 0!==t&&!Array.isArray(t))return!1;return t.every((t=>e.includes(t)))}(t.requires,e);return r&&s&&o&&n&&i}class A extends r{}A.AUTO=new A,A.BLUE=new A,A.YELLOW=new A,A.GREEN=new A,A.RED=new A,A.closeEnum();class W extends r{}W.LOG=new W,W.ERROR=new W,W.closeEnum();const $=new Map([[A.AUTO,t=>t],[A.BLUE,e=>t.blue(e)],[A.YELLOW,e=>t.yellow(e)],[A.GREEN,e=>t.green(e)],[A.RED,e=>t.red(e)]]),U=new e({label:"Workingâ€¦"});class D{constructor(t){if(!(t instanceof j))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=t,function(t){const e=t.runner;e.on("start",t.onStart.bind(t)),e.on("step:start",t.onStepStart.bind(t)),e.on("step:end",t.onStepEnd.bind(t)),e.on("end",t.onEnd.bind(t)),e.on("error",t.onError.bind(t))}(this)}log(t,{type:e=W.LOG,color:r=A.AUTO}={}){if(!(e instanceof W))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof A))throw new TypeError("Color option must a LoggerColor instance");const s=e===W.LOG?"log":"error",o=$.get(r);console[s](o(t))}async onStart(){this.log("Executing testsâ€¦",{color:A.YELLOW})}async onStepStart({name:t}){this.log(`---${t}---`,{color:A.BLUE}),await U.show()}async onStepEnd({name:e,report:r},s,o){if(await U.hide(),await r(s,this,o),!s.ok)return this.log(`Step ${t.bold(e)} failed with errors. Skipping subsequent steps.`,{color:A.RED,type:W.ERROR});this.log(`Step ${t.bold(e)} finished successfully.`,{color:A.GREEN})}async onEnd(t){if(await U.hide(),!t)return this.log("There were some errors alonside the way ðŸ˜¿",{color:A.RED});this.log("All steps finished correctly ðŸŽ‰",{color:A.GREEN})}async onError(t){await U.hide(),this.log("ðŸš¨ Error occured:",{color:A.RED,type:W.ERROR}),this.log(t,{type:W.ERROR})}}async function G(t,e){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");if(!e||"object"!=typeof e||Array.isArray(e))throw new TypeError("Provided code coverage data must be an object");return{name:"code coverage",ok:!0,results:a(e)}}const M=[{id:"lint",name:"Linter",watchable:!0,run:t=>N("./workers/linter.js",t),report:async function({results:t},e){const r=new c,s=(await r.loadFormatter("stylish")).format(t);e.log(s)}},{id:"test",name:"Tester",watchable:!0,run:t=>N("./workers/tester.js",t),report({output:t},e){e.log(t)}},{id:"coverage",name:"Code Coverage",watchable:!0,requires:["test"],run:(t,{test:{coverage:e}})=>G(t,e),report:function({results:t},e,{projectPath:r}){const s=l.createContext({dir:u(r,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),o=h.create("lcovonly"),n=h.create("text");o.execute(s),n.execute(s)}},{id:"codecov",name:"CodeCov",watchable:!1,requires:["coverage"],run:t=>N("./workers/codecov.js",t),report:function({results:t},e){t.skipped?e.log("CodeCov upload skipped",{color:A.YELLOW}):(e.log(t.stdout),t.stderr&&e.log(t.stderr,{type:W.ERROR,color:A.RED}))}}];async function N(t,...e){const r=new o(t),s=await n(r),a=await s(...e);return await i.terminate(s),a}const B=Symbol("config"),Y=Symbol("bannerEmitted"),F=Symbol("isInTheMiddleOfRun"),I=Symbol("scheduledRun");class z{constructor(t,e,r={}){if(!(t instanceof k))throw new TypeError("The runner parameter must be a valid Runner instance.");if(!(e instanceof D))throw new TypeError("The logger parameter must be a valid Logger instance.");if(!r||Array.isArray(r)||"object"!=typeof r)throw new TypeError("The config parameter must be an object.");this.runner=t,this.logger=e,this.watcher=null,this.continuous=!1,this[B]=r,this[Y]=!1,this[F]=!1,this._init(r)}async run(){if(this[Y]||(this.logger.log("MLT v0.7.0"),this[Y]=!0),this[F])return;this[F]=!0;const t=await this.runner.run(this.path)?0:1;return this[F]=!1,t}watch(){const t=s.watch("{bin,src,tests}/**/*.js",{persistent:!0,ignoreInitial:!0,cwd:process.cwd()});return t.on("all",(()=>{this.scheduleRun()})),this.continuous=!0,this.watcher=t,t}scheduleRun(){if(!this[I]){if(!this[F])return this.run();this[I]=!0,this.runner.once("end",(()=>{this[I]=!1,this.run()}))}}start(){return this[B].isWatch&&this.watch(),this.run()}_init({path:t=process.cwd(),requestedSteps:e=["lint","test","coverage","codecov"],isWatch:r=!1}={}){this.path=t;const s=function({requestedSteps:t,isWatch:e=!1}={}){const r=t.map((t=>M.find((e=>e.id===t))||t)),s=r.filter((t=>"string"==typeof t));if(s.length>0){const t=s.map((t=>`"${t}"`)).join(", ");throw new TypeError(`Provided step names (${t}) are incorrect`)}if(e)return r.filter((t=>t.watchable));return r}({requestedSteps:e,isWatch:r});this.runner.addSteps(s)}}function V(t){const e=new k,r=new D(e);return new z(e,r,t)}const H=p(m);async function J(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");const e=new c({useEslintrc:!1,cwd:t,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/__fixtures__/**/*.js"]}}),r=await async function(t){const e=["src/**/*.js","bin/**/*","tests/**/*.js"],r=e.map((e=>H(e,{cwd:t})));return(await Promise.all(r)).reduce(((t,r,s)=>0===r.length?t:[...t,e[s]]),[])}(t),s=await e.lintFiles(r);return{name:"linter",ok:K(s),results:s}}function K(t){return t.every((({errorCount:t})=>0===t))}const{Base:Q,Spec:X}=w;class Z extends X{constructor(t){const e=[],r={};let s=!0;const o=Q.consoleLog;Q.consoleLog=function(...t){e.push(d(...t))},super(t),t.on("test end",(({file:t,state:e,title:s})=>{void 0===r[t]&&(r[t]={}),r[t][s]=e})),t.once("fail",(()=>{s=!1})),t.once("end",(()=>{Q.consoleLog=o,t.suite.results={results:r,ok:s,output:e.join("\n")}}))}}const tt='import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();',et=new Set;async function rt(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");var e;!function(t){if(et.has(t))return;const e=u(t,"tests"),r=u(e,"__fixtures__");y((t=>t.startsWith(tt)?t:`${tt}${t}`),{exts:[".js"],matcher:t=>t.startsWith(e)&&!t.startsWith(r)}),et.add(t)}(t),g({cache:!1,caller:{name:"mlt",supportsStaticESM:!1,supportsDynamicImport:!0},babelrc:!1,presets:[[b,{targets:{node:"16.12.0"}}]]}),function(t){const e=u(t,"src"),r=E({coverageVariable:"__mltCoverage__"});y(((t,e)=>r.instrumentSync(t,e)),{exts:[".js"],matcher:t=>t.startsWith(e)})}(t),e=t,Object.keys(require.cache).forEach((t=>{t.startsWith(e)&&delete require.cache[t]}));const r=new f({reporter:Z,timeout:3e4});var s;return(await(s=t,H("tests/**/*.js",{cwd:s,ignore:["tests/__fixtures__/**/*.js","tests/__helpers__/**/*.js"],realpath:!0}))).forEach((t=>{r.addFile(t)})),new Promise((t=>{r.run((()=>{t({name:"tester",...r.suite.results,coverage:global.__mltCoverage__})}))}))}const st=S.chmod,ot=p(R);async function nt(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");const e={name:"codecov"};if(!T||process.env.NO_CODECOV)return Object.assign({},e,{ok:!0,results:{skipped:!0}});const r=await async function(t,e){["linux","darwin","win32"].includes(t)||(t="linux");const r={linux:"codecov",darwin:"codecov",win32:"codecov.exe"}[t],s=`https://uploader.codecov.io/latest/${{linux:"linux",darwin:"macos",win32:"windows"}[t]}/${r}`;try{const t=await(o=s,new Promise(((t,e)=>{v(o,(r=>{if(200!==r.statusCode)return e();t(r)})).on("error",e)}))),n=u(e,r),i=C(n);return await ot(t,i),n}catch(t){throw new Error("Can't download Codecov uploader")}var o}(process.platform,t);await st(r,"755");const{exitCode:s,stdout:o,stderr:n}=await function(t,e){return new Promise((r=>{const s=_(t,{cwd:e},((t,e,o)=>{r({exitCode:s.exitCode,stdout:e,stderr:o})}))}))}(r,t);return Object.assign({},e,{ok:0===s,results:{stdout:o,stderr:n}})}export{G as codeCoverage,nt as codecov,J as linter,V as mlt,rt as tester};
//# sourceMappingURL=mocha-lib-tester.mjs.map
