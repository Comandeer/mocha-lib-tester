/*! @comandeer/mocha-lib-tester v0.7.0 | (c) 2022 Comandeer | MIT license (see LICENSE) */
import t from"threads/worker";import e from"chalk";import r from"@comandeer/cli-spinner";import{Enumify as o}from"enumify";import s from"chokidar";import{Worker as n,spawn as i,Thread as a}from"threads";import{createCoverageMap as c}from"istanbul-lib-coverage";import{ESLint as u}from"eslint";import{resolve as l}from"path";import p from"istanbul-lib-report";import h from"istanbul-reports";import{promisify as d,format as f}from"util";import m from"glob";import w,{reporters as y}from"mocha";import{addHook as g}from"pirates";import b from"@babel/register";import E from"@babel/preset-env";import{createInstrumenter as v}from"istanbul-lib-instrument";import{get as _}from"https";import{exec as C}from"child_process";import{promises as S,createWriteStream as j}from"fs";import{pipeline as R}from"stream";import T from"is-ci";function x(t){var e=t.default;if("function"==typeof e){var r=function(){return e.apply(this,arguments)};r.prototype=e.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(t).forEach((function(e){var o=Object.getOwnPropertyDescriptor(t,e);Object.defineProperty(r,e,o.get?o:{enumerable:!0,get:function(){return t[e]}})})),r}var L={};const O=Symbol("listeners"),P=Symbol("onceListeners");class k{constructor(){this[O]=new Map,this[P]=new Map}on(t,e){this._getListenersCollection(t).add(e)}once(t,e){this.on(t,e);this._getListenersCollection(t,this[P]).add(e)}off(t,e){const r=this._getListenersCollection(t),o=this._getListenersCollection(t,this[P]);r.delete(e),o.delete(e)}async emit(t,...e){const r=this._getListenersCollection(t),o=this._getListenersCollection(t,this[P]);for(const s of r)await s(...e),o.has(s)&&this.off(t,s)}_getListenersCollection(t,e=this[O]){if(e.has(t))return e.get(t);const r=new Set;return e.set(t,r),r}}const q=Symbol("steps"),A=Symbol("stepResults");class W extends k{constructor(){super(),this[q]=Object.freeze(new Set),this[A]={}}get steps(){return this[q]}addStep(t){if(!$(t,[...this.steps].map((({id:t})=>t))))throw new TypeError("Provided object must be a valid step definition");this.steps.add(t)}addSteps(t){if(!(Array.isArray(t)&&t.every((t=>$(t)))))throw new TypeError("Provided array must contain only valid step definitions");t.forEach((t=>{this.addStep(t)}))}async run(t=process.cwd()){if(!("string"==typeof(e=t)&&e.trim().length>0))throw new TypeError("Provided path must be a non-empty string");var e;await this.emit("start");const r=[...this.steps];return this._processSteps(r,t)}async _processSteps(t,e){const r=async t=>(await this.emit("end",t),t),o=t.shift(),s=this._constructContext(e);if(!o)return r(!0);await this.emit("step:start",o,s);try{const n=this._constructRequiresParameter(o),i=await o.run(e,n);if(!function(t){if(!t||"object"!=typeof t)return!1;return t.results&&"object"==typeof t.results}(i))throw new TypeError(`Step ${o.name} didn't return correct results`);if(this[A][o.id]=i,await this.emit("step:end",o,i,s),!i.ok)return r(!1);if(0===t.length)return r(!0)}catch(t){return await this.emit("error",t),r(!1)}return this._processSteps(t,e)}_constructRequiresParameter({requires:t}){return t?t.reduce(((t,e)=>({...t,...{[e]:this[A][e]}})),{}):{}}_constructContext(t){return{projectPath:t}}}function $(t,e){if(!t||"object"!=typeof t)return!1;const r=function(t){if("string"!=typeof t||0===t.trim().length)return!1;const e=t===t.toLowerCase(),r=!/\s/.test(t);return e&&r}(t.id),o="string"==typeof t.name&&t.name.trim().length>0,s="function"==typeof t.run,n="function"==typeof t.report,i=!Array.isArray(e)||function(t,e){if(void 0===t)return!0;if(void 0!==t&&!Array.isArray(t))return!1;return t.every((t=>e.includes(t)))}(t.requires,e);return r&&o&&s&&n&&i}class D extends o{}D.AUTO=new D,D.BLUE=new D,D.YELLOW=new D,D.GREEN=new D,D.RED=new D,D.closeEnum();class U extends o{}U.LOG=new U,U.ERROR=new U,U.closeEnum();const M=new Map([[D.AUTO,t=>t],[D.BLUE,t=>e.blue(t)],[D.YELLOW,t=>e.yellow(t)],[D.GREEN,t=>e.green(t)],[D.RED,t=>e.red(t)]]),G=new r({label:"Workingâ€¦"});class N{constructor(t){if(!(t instanceof k))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=t,function(t){const e=t.runner;e.on("start",t.onStart.bind(t)),e.on("step:start",t.onStepStart.bind(t)),e.on("step:end",t.onStepEnd.bind(t)),e.on("end",t.onEnd.bind(t)),e.on("error",t.onError.bind(t))}(this)}log(t,{type:e=U.LOG,color:r=D.AUTO}={}){if(!(e instanceof U))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof D))throw new TypeError("Color option must a LoggerColor instance");const o=e===U.LOG?"log":"error",s=M.get(r);console[o](s(t))}async onStart(){this.log("Executing testsâ€¦",{color:D.YELLOW})}async onStepStart({name:t}){this.log(`---${t}---`,{color:D.BLUE}),await G.show()}async onStepEnd({name:t,report:r},o,s){if(await G.hide(),await r(o,this,s),!o.ok)return this.log(`Step ${e.bold(t)} failed with errors. Skipping subsequent steps.`,{color:D.RED,type:U.ERROR});this.log(`Step ${e.bold(t)} finished successfully.`,{color:D.GREEN})}async onEnd(t){if(await G.hide(),!t)return this.log("There were some errors alonside the way ðŸ˜¿",{color:D.RED});this.log("All steps finished correctly ðŸŽ‰",{color:D.GREEN})}async onError(t){await G.hide(),this.log("ðŸš¨ Error occured:",{color:D.RED,type:U.ERROR}),this.log(t,{type:U.ERROR})}}async function B(t,e){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");if(!e||"object"!=typeof e||Array.isArray(e))throw new TypeError("Provided code coverage data must be an object");return{name:"code coverage",ok:!0,results:c(e)}}const Y=[{id:"lint",name:"Linter",watchable:!0,run:t=>z("./workers/linter.js",t),report:async function({results:t},e){const r=new u,o=(await r.loadFormatter("stylish")).format(t);e.log(o)}},{id:"test",name:"Tester",watchable:!0,run:t=>z("./workers/tester.js",t),report({output:t},e){e.log(t)}},{id:"coverage",name:"Code Coverage",watchable:!0,requires:["test"],run:(t,{test:{coverage:e}})=>B(t,e),report:function({results:t},e,{projectPath:r}){const o=p.createContext({dir:l(r,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),s=h.create("lcovonly"),n=h.create("text");s.execute(o),n.execute(o)}},{id:"codecov",name:"CodeCov",watchable:!1,requires:["coverage"],run:t=>z("./workers/codecov.js",t),report:function({results:t},e){t.skipped?e.log("CodeCov upload skipped",{color:D.YELLOW}):(e.log(t.stdout),t.stderr&&e.log(t.stderr,{type:U.ERROR,color:D.RED}))}}];async function z(t,...e){const r=new n(t),o=await i(r),s=await o(...e);return await a.terminate(o),s}const F=Symbol("config"),I=Symbol("bannerEmitted"),V=Symbol("isInTheMiddleOfRun"),H=Symbol("scheduledRun");class J{constructor(t,e,r={}){if(!(t instanceof W))throw new TypeError("The runner parameter must be a valid Runner instance.");if(!(e instanceof N))throw new TypeError("The logger parameter must be a valid Logger instance.");if(!r||Array.isArray(r)||"object"!=typeof r)throw new TypeError("The config parameter must be an object.");this.runner=t,this.logger=e,this.watcher=null,this.continuous=!1,this[F]=r,this[I]=!1,this[V]=!1,this._init(r)}async run(){if(this[I]||(this.logger.log("MLT v0.7.0"),this[I]=!0),this[V])return;this[V]=!0;const t=await this.runner.run(this.path)?0:1;return this[V]=!1,t}watch(){const t=s.watch("{bin,src,tests}/**/*.js",{persistent:!0,ignoreInitial:!0,cwd:process.cwd()});return t.on("all",(()=>{this.scheduleRun()})),this.continuous=!0,this.watcher=t,t}scheduleRun(){if(!this[H]){if(!this[V])return this.run();this[H]=!0,this.runner.once("end",(()=>{this[H]=!1,this.run()}))}}start(){return this[F].isWatch&&this.watch(),this.run()}_init({path:t=process.cwd(),requestedSteps:e=["lint","test","coverage","codecov"],isWatch:r=!1}={}){this.path=t;const o=function({requestedSteps:t,isWatch:e=!1}={}){const r=t.map((t=>Y.find((e=>e.id===t))||t)),o=r.filter((t=>"string"==typeof t));if(o.length>0){const t=o.map((t=>`"${t}"`)).join(", ");throw new TypeError(`Provided step names (${t}) are incorrect`)}if(e)return r.filter((t=>t.watchable));return r}({requestedSteps:e,isWatch:r});this.runner.addSteps(o)}}const K=d(m);function Q(t){return t.every((({errorCount:t})=>0===t))}const{Base:X,Spec:Z}=y;class tt extends Z{constructor(t){const e=[],r={};let o=!0;const s=X.consoleLog;X.consoleLog=function(...t){e.push(f(...t))},super(t),t.on("test end",(({file:t,state:e,title:o})=>{void 0===r[t]&&(r[t]={}),r[t][o]=e})),t.once("fail",(()=>{o=!1})),t.once("end",(()=>{X.consoleLog=s,t.suite.results={results:r,ok:o,output:e.join("\n")}}))}}const et='import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();',rt=new Set;const ot=S.chmod,st=d(R);var nt=x(Object.freeze({__proto__:null,mlt:function(t){const e=new W,r=new N(e);return new J(e,r,t)},linter:async function(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");const e=new u({useEslintrc:!1,cwd:t,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/__fixtures__/**/*.js"]}}),r=await async function(t){const e=["src/**/*.js","bin/**/*","tests/**/*.js"],r=e.map((e=>K(e,{cwd:t})));return(await Promise.all(r)).reduce(((t,r,o)=>0===r.length?t:[...t,e[o]]),[])}(t),o=await e.lintFiles(r);return{name:"linter",ok:Q(o),results:o}},tester:async function(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");var e;!function(t){if(rt.has(t))return;const e=l(t,"tests"),r=l(e,"__fixtures__");g((t=>t.startsWith(et)?t:`${et}${t}`),{exts:[".js"],matcher:t=>t.startsWith(e)&&!t.startsWith(r)}),rt.add(t)}(t),b({cache:!1,caller:{name:"mlt",supportsStaticESM:!1,supportsDynamicImport:!0},babelrc:!1,presets:[[E,{targets:{node:"16.12.0"}}]]}),function(t){const e=l(t,"src"),r=v({coverageVariable:"__mltCoverage__"});g(((t,e)=>r.instrumentSync(t,e)),{exts:[".js"],matcher:t=>t.startsWith(e)})}(t),e=t,Object.keys(require.cache).forEach((t=>{t.startsWith(e)&&delete require.cache[t]}));const r=new w({reporter:tt,timeout:3e4});var o;return(await(o=t,K("tests/**/*.js",{cwd:o,ignore:["tests/__fixtures__/**/*.js","tests/__helpers__/**/*.js"],realpath:!0}))).forEach((t=>{r.addFile(t)})),new Promise((t=>{r.run((()=>{t({name:"tester",...r.suite.results,coverage:global.__mltCoverage__})}))}))},codeCoverage:B,codecov:async function(t){if("string"!=typeof t||0===t.length)throw new TypeError("Provided path must be a non-empty string");const e={name:"codecov"};if(!T||process.env.NO_CODECOV)return Object.assign({},e,{ok:!0,results:{skipped:!0}});const r=await async function(t,e){["linux","darwin","win32"].includes(t)||(t="linux");const r={linux:"codecov",darwin:"codecov",win32:"codecov.exe"}[t],o=`https://uploader.codecov.io/latest/${{linux:"linux",darwin:"macos",win32:"windows"}[t]}/${r}`;try{const t=await(s=o,new Promise(((t,e)=>{_(s,(r=>{if(200!==r.statusCode)return e();t(r)})).on("error",e)}))),n=l(e,r),i=j(n);return await st(t,i),n}catch(t){throw new Error("Can't download Codecov uploader")}var s}(process.platform,t);await ot(r,"755");const{exitCode:o,stdout:s,stderr:n}=await function(t,e){return new Promise((r=>{const o=C(t,{cwd:e},((t,e,s)=>{r({exitCode:o.exitCode,stdout:e,stderr:s})}))}))}(r,t);return Object.assign({},e,{ok:0===o,results:{stdout:s,stderr:n}})}}));const{expose:it}=t,{linter:at}=nt;it((t=>at(t)));export{L as default};
//# sourceMappingURL=linter.mjs.map
