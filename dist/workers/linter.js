/*! @comandeer/mocha-lib-tester v0.7.0 | (c) 2022 Comandeer | MIT license (see LICENSE) */
"use strict";var e=require("threads/worker"),t=require("chalk"),r=require("@comandeer/cli-spinner"),s=require("enumify"),n=require("chokidar"),o=require("threads"),i=require("istanbul-lib-coverage"),a=require("eslint"),c=require("path"),u=require("istanbul-lib-report"),l=require("istanbul-reports"),d=require("util"),h=require("glob"),p=require("mocha"),f=require("pirates"),w=require("@babel/register"),m=require("@babel/preset-env"),y=require("istanbul-lib-instrument"),g=require("https"),b=require("child_process"),v=require("fs"),E=require("stream"),_=require("is-ci");function S(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var q=S(e),C=S(t),j=S(r),L=S(n),R=S(u),T=S(l),x=S(h),O=S(p),k=S(w),P=S(m),A=S(_);function W(e){var t=e.default;if("function"==typeof t){var r=function(){return t.apply(this,arguments)};r.prototype=t.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(e).forEach((function(t){var s=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,s.get?s:{enumerable:!0,get:function(){return e[t]}})})),r}const $=Symbol("listeners"),D=Symbol("onceListeners");class M{constructor(){this[$]=new Map,this[D]=new Map}on(e,t){this._getListenersCollection(e).add(t)}once(e,t){this.on(e,t);this._getListenersCollection(e,this[D]).add(t)}off(e,t){const r=this._getListenersCollection(e),s=this._getListenersCollection(e,this[D]);r.delete(t),s.delete(t)}async emit(e,...t){const r=this._getListenersCollection(e),s=this._getListenersCollection(e,this[D]);for(const n of r)await n(...t),s.has(n)&&this.off(e,n)}_getListenersCollection(e,t=this[$]){if(t.has(e))return t.get(e);const r=new Set;return t.set(e,r),r}}const U=Symbol("steps"),G=Symbol("stepResults");class N extends M{constructor(){super(),this[U]=Object.freeze(new Set),this[G]={}}get steps(){return this[U]}addStep(e){if(!B(e,[...this.steps].map((({id:e})=>e))))throw new TypeError("Provided object must be a valid step definition");this.steps.add(e)}addSteps(e){if(!(Array.isArray(e)&&e.every((e=>B(e)))))throw new TypeError("Provided array must contain only valid step definitions");e.forEach((e=>{this.addStep(e)}))}async run(e=process.cwd()){if(!("string"==typeof(t=e)&&t.trim().length>0))throw new TypeError("Provided path must be a non-empty string");var t;await this.emit("start");const r=[...this.steps];return this._processSteps(r,e)}async _processSteps(e,t){const r=async e=>(await this.emit("end",e),e),s=e.shift(),n=this._constructContext(t);if(!s)return r(!0);await this.emit("step:start",s,n);try{const o=this._constructRequiresParameter(s),i=await s.run(t,o);if(!function(e){if(!e||"object"!=typeof e)return!1;return e.results&&"object"==typeof e.results}(i))throw new TypeError(`Step ${s.name} didn't return correct results`);if(this[G][s.id]=i,await this.emit("step:end",s,i,n),!i.ok)return r(!1);if(0===e.length)return r(!0)}catch(e){return await this.emit("error",e),r(!1)}return this._processSteps(e,t)}_constructRequiresParameter({requires:e}){return e?e.reduce(((e,t)=>({...e,...{[t]:this[G][t]}})),{}):{}}_constructContext(e){return{projectPath:e}}}function B(e,t){if(!e||"object"!=typeof e)return!1;const r=function(e){if("string"!=typeof e||0===e.trim().length)return!1;const t=e===e.toLowerCase(),r=!/\s/.test(e);return t&&r}(e.id),s="string"==typeof e.name&&e.name.trim().length>0,n="function"==typeof e.run,o="function"==typeof e.report,i=!Array.isArray(t)||function(e,t){if(void 0===e)return!0;if(void 0!==e&&!Array.isArray(e))return!1;return e.every((e=>t.includes(e)))}(e.requires,t);return r&&s&&n&&o&&i}class I extends s.Enumify{}I.AUTO=new I,I.BLUE=new I,I.YELLOW=new I,I.GREEN=new I,I.RED=new I,I.closeEnum();class Y extends s.Enumify{}Y.LOG=new Y,Y.ERROR=new Y,Y.closeEnum();const z=new Map([[I.AUTO,e=>e],[I.BLUE,e=>C.default.blue(e)],[I.YELLOW,e=>C.default.yellow(e)],[I.GREEN,e=>C.default.green(e)],[I.RED,e=>C.default.red(e)]]),F=new j.default({label:"Workingâ€¦"});class H{constructor(e){if(!(e instanceof M))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=e,function(e){const t=e.runner;t.on("start",e.onStart.bind(e)),t.on("step:start",e.onStepStart.bind(e)),t.on("step:end",e.onStepEnd.bind(e)),t.on("end",e.onEnd.bind(e)),t.on("error",e.onError.bind(e))}(this)}log(e,{type:t=Y.LOG,color:r=I.AUTO}={}){if(!(t instanceof Y))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof I))throw new TypeError("Color option must a LoggerColor instance");const s=t===Y.LOG?"log":"error",n=z.get(r);console[s](n(e))}async onStart(){this.log("Executing testsâ€¦",{color:I.YELLOW})}async onStepStart({name:e}){this.log(`---${e}---`,{color:I.BLUE}),await F.show()}async onStepEnd({name:e,report:t},r,s){if(await F.hide(),await t(r,this,s),!r.ok)return this.log(`Step ${C.default.bold(e)} failed with errors. Skipping subsequent steps.`,{color:I.RED,type:Y.ERROR});this.log(`Step ${C.default.bold(e)} finished successfully.`,{color:I.GREEN})}async onEnd(e){if(await F.hide(),!e)return this.log("There were some errors alonside the way ðŸ˜¿",{color:I.RED});this.log("All steps finished correctly ðŸŽ‰",{color:I.GREEN})}async onError(e){await F.hide(),this.log("ðŸš¨ Error occured:",{color:I.RED,type:Y.ERROR}),this.log(e,{type:Y.ERROR})}}async function V(e,t){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Provided code coverage data must be an object");return{name:"code coverage",ok:!0,results:i.createCoverageMap(t)}}const J=[{id:"lint",name:"Linter",watchable:!0,run:e=>K("./workers/linter.js",e),report:async function({results:e},t){const r=new a.ESLint,s=(await r.loadFormatter("stylish")).format(e);t.log(s)}},{id:"test",name:"Tester",watchable:!0,run:e=>K("./workers/tester.js",e),report({output:e},t){t.log(e)}},{id:"coverage",name:"Code Coverage",watchable:!0,requires:["test"],run:(e,{test:{coverage:t}})=>V(e,t),report:function({results:e},t,{projectPath:r}){const s=R.default.createContext({dir:c.resolve(r,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:e}),n=T.default.create("lcovonly"),o=T.default.create("text");n.execute(s),o.execute(s)}},{id:"codecov",name:"CodeCov",watchable:!1,requires:["coverage"],run:e=>K("./workers/codecov.js",e),report:function({results:e},t){e.skipped?t.log("CodeCov upload skipped",{color:I.YELLOW}):(t.log(e.stdout),e.stderr&&t.log(e.stderr,{type:Y.ERROR,color:I.RED}))}}];async function K(e,...t){const r=new o.Worker(e),s=await o.spawn(r),n=await s(...t);return await o.Thread.terminate(s),n}const Q=Symbol("config"),X=Symbol("bannerEmitted"),Z=Symbol("isInTheMiddleOfRun"),ee=Symbol("scheduledRun");class te{constructor(e,t,r={}){if(!(e instanceof N))throw new TypeError("The runner parameter must be a valid Runner instance.");if(!(t instanceof H))throw new TypeError("The logger parameter must be a valid Logger instance.");if(!r||Array.isArray(r)||"object"!=typeof r)throw new TypeError("The config parameter must be an object.");this.runner=e,this.logger=t,this.watcher=null,this.continuous=!1,this[Q]=r,this[X]=!1,this[Z]=!1,this._init(r)}async run(){if(this[X]||(this.logger.log("MLT v0.7.0"),this[X]=!0),this[Z])return;this[Z]=!0;const e=await this.runner.run(this.path)?0:1;return this[Z]=!1,e}watch(){const e=L.default.watch("{bin,src,tests}/**/*.js",{persistent:!0,ignoreInitial:!0,cwd:process.cwd()});return e.on("all",(()=>{this.scheduleRun()})),this.continuous=!0,this.watcher=e,e}scheduleRun(){if(!this[ee]){if(!this[Z])return this.run();this[ee]=!0,this.runner.once("end",(()=>{this[ee]=!1,this.run()}))}}start(){return this[Q].isWatch&&this.watch(),this.run()}_init({path:e=process.cwd(),requestedSteps:t=["lint","test","coverage","codecov"],isWatch:r=!1}={}){this.path=e;const s=function({requestedSteps:e,isWatch:t=!1}={}){const r=e.map((e=>J.find((t=>t.id===e))||e)),s=r.filter((e=>"string"==typeof e));if(s.length>0){const e=s.map((e=>`"${e}"`)).join(", ");throw new TypeError(`Provided step names (${e}) are incorrect`)}if(t)return r.filter((e=>e.watchable));return r}({requestedSteps:t,isWatch:r});this.runner.addSteps(s)}}const re=d.promisify(x.default);function se(e){return e.every((({errorCount:e})=>0===e))}const{Base:ne,Spec:oe}=p.reporters;class ie extends oe{constructor(e){const t=[],r={};let s=!0;const n=ne.consoleLog;ne.consoleLog=function(...e){t.push(d.format(...e))},super(e),e.on("test end",(({file:e,state:t,title:s})=>{void 0===r[e]&&(r[e]={}),r[e][s]=t})),e.once("fail",(()=>{s=!1})),e.once("end",(()=>{ne.consoleLog=n,e.suite.results={results:r,ok:s,output:t.join("\n")}}))}}const ae='import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();',ce=new Set;const ue=v.promises.chmod,le=d.promisify(E.pipeline);var de=W(Object.freeze({__proto__:null,mlt:function(e){const t=new N,r=new H(t);return new te(t,r,e)},linter:async function(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t=new a.ESLint({useEslintrc:!1,cwd:e,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/__fixtures__/**/*.js"]}}),r=await async function(e){const t=["src/**/*.js","bin/**/*","tests/**/*.js"],r=t.map((t=>re(t,{cwd:e})));return(await Promise.all(r)).reduce(((e,r,s)=>0===r.length?e:[...e,t[s]]),[])}(e),s=await t.lintFiles(r);return{name:"linter",ok:se(s),results:s}},tester:async function(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");!function(e){if(ce.has(e))return;const t=c.resolve(e,"tests"),r=c.resolve(t,"__fixtures__");f.addHook((e=>e.startsWith(ae)?e:`${ae}${e}`),{exts:[".js"],matcher:e=>e.startsWith(t)&&!e.startsWith(r)}),ce.add(e)}(e),k.default({cache:!1,caller:{name:"mlt",supportsStaticESM:!1,supportsDynamicImport:!0},babelrc:!1,presets:[[P.default,{targets:{node:"16.12.0"}}]]}),function(e){const t=c.resolve(e,"src"),r=y.createInstrumenter({coverageVariable:"__mltCoverage__"});f.addHook(((e,t)=>r.instrumentSync(e,t)),{exts:[".js"],matcher:e=>e.startsWith(t)})}(e),function(e){Object.keys(require.cache).forEach((t=>{t.startsWith(e)&&delete require.cache[t]}))}(e);const t=new O.default({reporter:ie,timeout:3e4});var r;return(await(r=e,re("tests/**/*.js",{cwd:r,ignore:["tests/__fixtures__/**/*.js","tests/__helpers__/**/*.js"],realpath:!0}))).forEach((e=>{t.addFile(e)})),new Promise((e=>{t.run((()=>{e({name:"tester",...t.suite.results,coverage:global.__mltCoverage__})}))}))},codeCoverage:V,codecov:async function(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t={name:"codecov"};if(!A.default||process.env.NO_CODECOV)return Object.assign({},t,{ok:!0,results:{skipped:!0}});const r=await async function(e,t){["linux","darwin","win32"].includes(e)||(e="linux");const r={linux:"codecov",darwin:"codecov",win32:"codecov.exe"}[e],s=`https://uploader.codecov.io/latest/${{linux:"linux",darwin:"macos",win32:"windows"}[e]}/${r}`;try{const e=await(n=s,new Promise(((e,t)=>{g.get(n,(r=>{if(200!==r.statusCode)return t();e(r)})).on("error",t)}))),o=c.resolve(t,r),i=v.createWriteStream(o);return await le(e,i),o}catch(e){throw new Error("Can't download Codecov uploader")}var n}(process.platform,e);await ue(r,"755");const{exitCode:s,stdout:n,stderr:o}=await function(e,t){return new Promise((r=>{const s=b.exec(e,{cwd:t},((e,t,n)=>{r({exitCode:s.exitCode,stdout:t,stderr:n})}))}))}(r,e);return Object.assign({},t,{ok:0===s,results:{stdout:n,stderr:o}})}}));const{expose:he}=q.default,{linter:pe}=de;he((e=>pe(e))),module.exports={};
//# sourceMappingURL=linter.js.map
