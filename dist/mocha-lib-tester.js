/*! @comandeer/mocha-lib-tester v0.2.0 | (c) 2021 Comandeer | MIT license (see LICENSE) */
"use strict";var e=require("eslint"),t=require("glob"),r=require("eslint/lib/cli-engine/formatters/stylish.js"),o=require("mocha"),n=require("util"),s=require("path"),i=require("pirates"),a=require("@babel/register"),c=require("@babel/preset-env"),u=require("istanbul-lib-instrument"),l=require("istanbul-lib-coverage"),d=require("istanbul-lib-report"),p=require("istanbul-reports"),f=require("child_process"),h=require("is-ci"),m=require("enumify"),g=require("events"),y=require("chalk");function E(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var w=E(r),b=E(o),v=E(a),C=E(c),S=E(d),q=E(p),x=E(h),T=E(g),L=E(y);function R(e,t){t.log(w.default(e))}function j(r){if("string"!=typeof r||0===r.length)throw new TypeError("Provided path must be a non-empty string");return new e.ESLint({useEslintrc:!1,cwd:r,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/fixtures/**/*.js"]}}).lintFiles((o=r,["src/**/*.js","bin/**/*","tests/**/*.js"].filter((e=>t.sync(e,{cwd:o}).length>0)))).then((e=>({name:"linter",ok:O(e),results:e,reporter:R})));var o}function O(e){return e.every((({errorCount:e})=>0===e))}const{Base:_,Spec:k}=o.reporters;class P extends k{constructor(e){const t=[],r={};let o=!0;const s=_.consoleLog;_.consoleLog=function(...e){t.push(n.format(...e))},super(e),e.on("test end",(({file:e,state:t,title:o})=>{void 0===r[e]&&(r[e]={}),r[e][o]=t})),e.once("fail",(()=>{o=!1})),e.once("end",(()=>{_.consoleLog=s,e.suite.results={results:r,ok:o,reporter(e,r){r.log(t.join("\n"))}}}))}}function A(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");!function(e){const t=s.resolve(e,"tests"),r=s.resolve(t,"fixtures");i.addHook((e=>`import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();${e}`),{exts:[".js"],matcher:e=>e.startsWith(t)&&!e.startsWith(r)})}(e),v.default({babelrc:!1,presets:[[C.default,{targets:{node:"12.0.0"}}]]}),function(e){const t=s.resolve(e,"src"),r=u.createInstrumenter({coverageVariable:"__mltCoverage__"});i.addHook(((e,t)=>r.instrumentSync(e,t)),{exts:[".js"],matcher:e=>e.startsWith(t)})}(e);const r=new b.default({reporter:P,timeout:15e3});var o;return(o=e,t.sync("tests/**/*.js",{cwd:o,ignore:["tests/fixtures/**/*.js","tests/helpers/**/*.js"],realpath:!0})).forEach((e=>{r.addFile(e)})),new Promise((e=>{r.run((()=>{e({name:"tester",...r.suite.results})}))}))}function U(e){return function(t){const r=S.default.createContext({dir:s.resolve(e,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),o=q.default.create("lcovonly"),n=q.default.create("text");o.execute(r),n.execute(r)}}class G extends m.Enumify{}function N(e,t){e.skipped?t.log("CodeCov upload skipped",{color:G.YELLOW}):t.log(e.stdout)}function W(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t={name:"codecov",reporter:N};return!x.default||process.env.NO_CODECOV?Object.assign({},t,{ok:!0,results:{skipped:!0}}):function(e){const t=s.resolve(__dirname,"..","node_modules","codecov","bin","codecov");return new Promise((r=>{const o=f.exec(`node ${t}`,{cwd:e},((e,t,n)=>{r({exitCode:o.exitCode,stdout:t,stderr:n})}))}))}(e).then((({exitCode:e,stdout:r,stderr:o})=>Object.assign({},t,{ok:0===e,results:{stdout:r,stderr:o}})))}G.AUTO=new G,G.BLUE=new G,G.YELLOW=new G,G.GREEN=new G,G.RED=new G,G.closeEnum();const D=Symbol("steps");class $ extends T.default{constructor(){super(),this[D]=Object.freeze(new Set)}get steps(){return this[D]}addStep(e){if(!B(e))throw new TypeError("Provided object must be a valid step definition");this.steps.add(e)}addSteps(e){if(!(Array.isArray(e)&&e.every((e=>B(e)))))throw new TypeError("Provided array must contain only valid step definitions");e.forEach((e=>{this.addStep(e)}))}run(){this.emit("start");const e=[...this.steps];return this._processSteps(e)}async _processSteps(e){const t=e=>(this.emit("end",e),e),r=e.shift();if(!r)return t(!0);this.emit("step:start",r);try{const o=await r.run();if(!function(e){if(!e||"object"!=typeof e)return!1;const t=e.results&&"object"==typeof e.results,r="function"==typeof e.reporter;return t&&r}(o))throw new TypeError(`Step ${r.name} didn't return correct results`);if(this.emit("step:end",r,o),!o.ok)return t(!1);if(0===e.length)return t(!0)}catch(e){return this.emit("error",e),t(!1)}return this._processSteps(e)}}function B(e){if(!e||"object"!=typeof e)return!1;const t="string"==typeof e.name&&e.name.trim().length>0,r="function"==typeof e.run;return t&&r}class M extends m.Enumify{}M.LOG=new M,M.ERROR=new M,M.closeEnum();const Y=new Map([[G.AUTO,e=>e],[G.BLUE,e=>L.default.blue(e)],[G.YELLOW,e=>L.default.yellow(e)],[G.GREEN,e=>L.default.green(e)],[G.RED,e=>L.default.red(e)]]);class z{constructor(e){if(!(e instanceof T.default))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=e,function(e){const t=e.runner;t.on("start",e.onStart.bind(e)),t.on("step:start",e.onStepStart.bind(e)),t.on("step:end",e.onStepEnd.bind(e)),t.on("end",e.onEnd.bind(e)),t.on("error",e.onError.bind(e))}(this)}log(e,{type:t=M.LOG,color:r=G.AUTO}={}){if(!(t instanceof M))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof G))throw new TypeError("Color option must a LoggerColor instance");const o=t===M.LOG?"log":"error",n=Y.get(r);console[o](n(e))}onStart(){this.log("MLT v0.2.0"),this.log("Executing testsâ€¦",{color:G.YELLOW})}onStepStart({name:e}){this.log(`---${e}---`,{color:G.BLUE})}onStepEnd({name:e},{ok:t,results:r,reporter:o}){if(o(r,this),!t)return this.log(`Step ${L.default.bold(e)} failed with errors. Skipping subsequent steps.`,{color:G.RED,type:M.ERROR});this.log(`Step ${L.default.bold(e)} finished successfully.`,{color:G.GREEN})}onEnd(e){if(!e)return this.log("There were some errors alonside the way ðŸ˜¿",{color:G.RED});this.log("All steps finished correctly ðŸŽ‰",{color:G.GREEN})}onError(e){this.log("ðŸš¨ Error occured:",{color:G.RED,type:M.ERROR}),this.log(e,{type:M.ERROR})}}module.exports=async function(){const e=process.cwd(),t=[{name:"Linter",run:()=>j(e)},{name:"Tester",run:()=>A(e)},{name:"Code Coverage",run:()=>function(e,t){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Provided code coverage data must be an object");const r=l.createCoverageMap(t);return Promise.resolve({name:"code coverage",ok:!0,results:r,reporter:U(e)})}(e,global.__mltCoverage__)},{name:"CodeCov",run:()=>W(e)}],r=new $;return new z(r),r.addSteps(t),await r.run()?0:1};
//# sourceMappingURL=mocha-lib-tester.js.map
