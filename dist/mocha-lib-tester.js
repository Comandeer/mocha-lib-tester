/*! @comandeer/mocha-lib-tester v0.3.0 | (c) 2021 Comandeer | MIT license (see LICENSE) */
"use strict";var e=require("eslint"),t=require("glob"),r=require("eslint/lib/cli-engine/formatters/stylish.js"),o=require("mocha"),n=require("util"),s=require("path"),i=require("pirates"),a=require("@babel/register"),c=require("@babel/preset-env"),u=require("istanbul-lib-instrument"),l=require("istanbul-lib-coverage"),d=require("istanbul-lib-report"),p=require("istanbul-reports"),f=require("child_process"),h=require("is-ci"),m=require("npm-run-path"),g=require("enumify"),y=require("events"),E=require("chalk");function w(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var v=w(r),b=w(o),C=w(a),R=w(c),S=w(d),q=w(p),T=w(h),x=w(m),L=w(y),j=w(E);function O(e,t){t.log(v.default(e))}function k(r){if("string"!=typeof r||0===r.length)throw new TypeError("Provided path must be a non-empty string");return new e.ESLint({useEslintrc:!1,cwd:r,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/fixtures/**/*.js"]}}).lintFiles((o=r,["src/**/*.js","bin/**/*","tests/**/*.js"].filter((e=>t.sync(e,{cwd:o}).length>0)))).then((e=>({name:"linter",ok:P(e),results:e,reporter:O})));var o}function P(e){return e.every((({errorCount:e})=>0===e))}const{Base:_,Spec:A}=o.reporters;class U extends A{constructor(e){const t=[],r={};let o=!0;const s=_.consoleLog;_.consoleLog=function(...e){t.push(n.format(...e))},super(e),e.on("test end",(({file:e,state:t,title:o})=>{void 0===r[e]&&(r[e]={}),r[e][o]=t})),e.once("fail",(()=>{o=!1})),e.once("end",(()=>{_.consoleLog=s,e.suite.results={results:r,ok:o,reporter(e,r){r.log(t.join("\n"))}}}))}}function D(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");!function(e){const t=s.resolve(e,"tests"),r=s.resolve(t,"fixtures");i.addHook((e=>`import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();${e}`),{exts:[".js"],matcher:e=>e.startsWith(t)&&!e.startsWith(r)})}(e),C.default({babelrc:!1,presets:[[R.default,{targets:{node:"12.0.0"}}]]}),function(e){const t=s.resolve(e,"src"),r=u.createInstrumenter({coverageVariable:"__mltCoverage__"});i.addHook(((e,t)=>r.instrumentSync(e,t)),{exts:[".js"],matcher:e=>e.startsWith(t)})}(e);const r=new b.default({reporter:U,timeout:15e3});var o;return(o=e,t.sync("tests/**/*.js",{cwd:o,ignore:["tests/fixtures/**/*.js","tests/helpers/**/*.js"],realpath:!0})).forEach((e=>{r.addFile(e)})),new Promise((e=>{r.run((()=>{e({name:"tester",...r.suite.results})}))}))}function G(e){return function(t){const r=S.default.createContext({dir:s.resolve(e,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),o=q.default.create("lcovonly"),n=q.default.create("text");o.execute(r),n.execute(r)}}class N extends g.Enumify{}N.AUTO=new N,N.BLUE=new N,N.YELLOW=new N,N.GREEN=new N,N.RED=new N,N.closeEnum();class W extends g.Enumify{}function $(e,t){e.skipped?t.log("CodeCov upload skipped",{color:N.YELLOW}):(t.log(e.stdout),e.stderr&&t.log(e.stderr,{type:W.ERROR,color:N.RED}))}function B(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t={name:"codecov",reporter:$};return!T.default||process.env.NO_CODECOV?Object.assign({},t,{ok:!0,results:{skipped:!0}}):function(e){return new Promise((t=>{const r=f.exec("codecov",{cwd:e,env:x.default.env()},((e,o,n)=>{t({exitCode:r.exitCode,stdout:o,stderr:n})}))}))}(e).then((({exitCode:e,stdout:r,stderr:o})=>Object.assign({},t,{ok:0===e,results:{stdout:r,stderr:o}})))}W.LOG=new W,W.ERROR=new W,W.closeEnum();const M=Symbol("steps");class Y extends L.default{constructor(){super(),this[M]=Object.freeze(new Set)}get steps(){return this[M]}addStep(e){if(!z(e))throw new TypeError("Provided object must be a valid step definition");this.steps.add(e)}addSteps(e){if(!(Array.isArray(e)&&e.every((e=>z(e)))))throw new TypeError("Provided array must contain only valid step definitions");e.forEach((e=>{this.addStep(e)}))}run(){this.emit("start");const e=[...this.steps];return this._processSteps(e)}async _processSteps(e){const t=e=>(this.emit("end",e),e),r=e.shift();if(!r)return t(!0);this.emit("step:start",r);try{const o=await r.run();if(!function(e){if(!e||"object"!=typeof e)return!1;const t=e.results&&"object"==typeof e.results,r="function"==typeof e.reporter;return t&&r}(o))throw new TypeError(`Step ${r.name} didn't return correct results`);if(this.emit("step:end",r,o),!o.ok)return t(!1);if(0===e.length)return t(!0)}catch(e){return this.emit("error",e),t(!1)}return this._processSteps(e)}}function z(e){if(!e||"object"!=typeof e)return!1;const t=function(e){if("string"!=typeof e||0===e.trim().length)return!1;const t=e===e.toLowerCase(),r=!/\s/.test(e);return t&&r}(e.id),r="string"==typeof e.name&&e.name.trim().length>0,o="function"==typeof e.run;return t&&r&&o}const F=new Map([[N.AUTO,e=>e],[N.BLUE,e=>j.default.blue(e)],[N.YELLOW,e=>j.default.yellow(e)],[N.GREEN,e=>j.default.green(e)],[N.RED,e=>j.default.red(e)]]);class H{constructor(e){if(!(e instanceof L.default))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=e,function(e){const t=e.runner;t.on("start",e.onStart.bind(e)),t.on("step:start",e.onStepStart.bind(e)),t.on("step:end",e.onStepEnd.bind(e)),t.on("end",e.onEnd.bind(e)),t.on("error",e.onError.bind(e))}(this)}log(e,{type:t=W.LOG,color:r=N.AUTO}={}){if(!(t instanceof W))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof N))throw new TypeError("Color option must a LoggerColor instance");const o=t===W.LOG?"log":"error",n=F.get(r);console[o](n(e))}onStart(){this.log("MLT v0.3.0"),this.log("Executing testsâ€¦",{color:N.YELLOW})}onStepStart({name:e}){this.log(`---${e}---`,{color:N.BLUE})}onStepEnd({name:e},{ok:t,results:r,reporter:o}){if(o(r,this),!t)return this.log(`Step ${j.default.bold(e)} failed with errors. Skipping subsequent steps.`,{color:N.RED,type:W.ERROR});this.log(`Step ${j.default.bold(e)} finished successfully.`,{color:N.GREEN})}onEnd(e){if(!e)return this.log("There were some errors alonside the way ðŸ˜¿",{color:N.RED});this.log("All steps finished correctly ðŸŽ‰",{color:N.GREEN})}onError(e){this.log("ðŸš¨ Error occured:",{color:N.RED,type:W.ERROR}),this.log(e,{type:W.ERROR})}}module.exports=async function(e=["lint","test","coverage","codecov"]){const t=process.cwd(),r=[{id:"lint",name:"Linter",run:()=>k(t)},{id:"test",name:"Tester",run:()=>D(t)},{id:"coverage",name:"Code Coverage",run:()=>function(e,t){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Provided code coverage data must be an object");const r=l.createCoverageMap(t);return Promise.resolve({name:"code coverage",ok:!0,results:r,reporter:G(e)})}(t,global.__mltCoverage__)},{id:"codecov",name:"CodeCov",run:()=>B(t)}],o=e.map((e=>r.find((({id:t})=>t===e))||e)),n=o.filter((e=>"string"==typeof e));if(n.length>0){const e=n.map((e=>`"${e}"`)).join(", ");throw new TypeError(`Provided step names (${e}) are incorrect`)}const s=new Y;return new H(s),s.addSteps(o),await s.run()?0:1};
//# sourceMappingURL=mocha-lib-tester.js.map
