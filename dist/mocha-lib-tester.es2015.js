/*! @comandeer/mocha-lib-tester v0.2.0 | (c) 2021 Comandeer | MIT license (see LICENSE) */
import{ESLint as e}from"eslint";import{sync as t}from"glob";import r from"eslint/lib/cli-engine/formatters/stylish.js";import o,{reporters as n}from"mocha";import{format as s}from"util";import{resolve as i}from"path";import{addHook as c}from"pirates";import a from"@babel/register";import p from"@babel/preset-env";import{createInstrumenter as l}from"istanbul-lib-instrument";import{createCoverageMap as u}from"istanbul-lib-coverage";import m from"istanbul-lib-report";import d from"istanbul-reports";import{exec as f}from"child_process";import h from"is-ci";import{Enumify as g}from"enumify";import y from"events";import E from"chalk";function w(e,t){t.log(r(e))}function b(r){if("string"!=typeof r||0===r.length)throw new TypeError("Provided path must be a non-empty string");return new e({useEslintrc:!1,cwd:r,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/fixtures/**/*.js"]}}).lintFiles((o=r,["src/**/*.js","bin/**/*","tests/**/*.js"].filter((e=>t(e,{cwd:o}).length>0)))).then((e=>({name:"linter",ok:v(e),results:e,reporter:w})));var o}function v(e){return e.every((({errorCount:e})=>0===e))}const{Base:C,Spec:S}=n;class T extends S{constructor(e){const t=[],r={};let o=!0;const n=C.consoleLog;C.consoleLog=function(...e){t.push(s(...e))},super(e),e.on("test end",(({file:e,state:t,title:o})=>{void 0===r[e]&&(r[e]={}),r[e][o]=t})),e.once("fail",(()=>{o=!1})),e.once("end",(()=>{C.consoleLog=n,e.suite.results={results:r,ok:o,reporter(e,r){r.log(t.join("\n"))}}}))}}function x(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");!function(e){const t=i(e,"tests"),r=i(t,"fixtures");c((e=>`import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();${e}`),{exts:[".js"],matcher:e=>e.startsWith(t)&&!e.startsWith(r)})}(e),a({babelrc:!1,presets:[[p,{targets:{node:"12.0.0"}}]]}),function(e){const t=i(e,"src"),r=l({coverageVariable:"__mltCoverage__"});c(((e,t)=>r.instrumentSync(e,t)),{exts:[".js"],matcher:e=>e.startsWith(t)})}(e);const r=new o({reporter:T,timeout:15e3});return t("tests/**/*.js",{cwd:e,ignore:["tests/fixtures/**/*.js","tests/helpers/**/*.js"],realpath:!0}).forEach((e=>{r.addFile(e)})),new Promise((e=>{r.run((()=>{e({name:"tester",...r.suite.results})}))}))}function L(e){return function(t){const r=m.createContext({dir:i(e,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),o=d.create("lcovonly"),n=d.create("text");o.execute(r),n.execute(r)}}class R extends g{}function O(e,t){e.skipped?t.log("CodeCov upload skipped",{color:R.YELLOW}):t.log(e.stdout)}function j(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t={name:"codecov",reporter:O};return!h||process.env.NO_CODECOV?Object.assign({},t,{ok:!0,results:{skipped:!0}}):function(e){const t=i(__dirname,"..","node_modules","codecov","bin","codecov");return new Promise((r=>{const o=f(`node ${t}`,{cwd:e},((e,t,n)=>{r({exitCode:o.exitCode,stdout:t,stderr:n})}))}))}(e).then((({exitCode:e,stdout:r,stderr:o})=>Object.assign({},t,{ok:0===e,results:{stdout:r,stderr:o}})))}R.AUTO=new R,R.BLUE=new R,R.YELLOW=new R,R.GREEN=new R,R.RED=new R,R.closeEnum();const _=Symbol("steps");class k extends y{constructor(){super(),this[_]=Object.freeze(new Set)}get steps(){return this[_]}addStep(e){if(!P(e))throw new TypeError("Provided object must be a valid step definition");this.steps.add(e)}addSteps(e){if(!(Array.isArray(e)&&e.every((e=>P(e)))))throw new TypeError("Provided array must contain only valid step definitions");e.forEach((e=>{this.addStep(e)}))}run(){this.emit("start");const e=[...this.steps];return this._processSteps(e)}async _processSteps(e){const t=e=>(this.emit("end",e),e),r=e.shift();if(!r)return t(!0);this.emit("step:start",r);try{const o=await r.run();if(!function(e){if(!e||"object"!=typeof e)return!1;const t=e.results&&"object"==typeof e.results,r="function"==typeof e.reporter;return t&&r}(o))throw new TypeError(`Step ${r.name} didn't return correct results`);if(this.emit("step:end",r,o),!o.ok)return t(!1);if(0===e.length)return t(!0)}catch(e){return this.emit("error",e),t(!1)}return this._processSteps(e)}}function P(e){if(!e||"object"!=typeof e)return!1;const t="string"==typeof e.name&&e.name.trim().length>0,r="function"==typeof e.run;return t&&r}class A extends g{}A.LOG=new A,A.ERROR=new A,A.closeEnum();const U=new Map([[R.AUTO,e=>e],[R.BLUE,e=>E.blue(e)],[R.YELLOW,e=>E.yellow(e)],[R.GREEN,e=>E.green(e)],[R.RED,e=>E.red(e)]]);class G{constructor(e){if(!(e instanceof y))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=e,function(e){const t=e.runner;t.on("start",e.onStart.bind(e)),t.on("step:start",e.onStepStart.bind(e)),t.on("step:end",e.onStepEnd.bind(e)),t.on("end",e.onEnd.bind(e)),t.on("error",e.onError.bind(e))}(this)}log(e,{type:t=A.LOG,color:r=R.AUTO}={}){if(!(t instanceof A))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof R))throw new TypeError("Color option must a LoggerColor instance");const o=t===A.LOG?"log":"error",n=U.get(r);console[o](n(e))}onStart(){this.log("MLT v0.2.0"),this.log("Executing testsâ€¦",{color:R.YELLOW})}onStepStart({name:e}){this.log(`---${e}---`,{color:R.BLUE})}onStepEnd({name:e},{ok:t,results:r,reporter:o}){if(o(r,this),!t)return this.log(`Step ${E.bold(e)} failed with errors. Skipping subsequent steps.`,{color:R.RED,type:A.ERROR});this.log(`Step ${E.bold(e)} finished successfully.`,{color:R.GREEN})}onEnd(e){if(!e)return this.log("There were some errors alonside the way ðŸ˜¿",{color:R.RED});this.log("All steps finished correctly ðŸŽ‰",{color:R.GREEN})}onError(e){this.log("ðŸš¨ Error occured:",{color:R.RED,type:A.ERROR}),this.log(e,{type:A.ERROR})}}async function N(){const e=process.cwd(),t=[{name:"Linter",run:()=>b(e)},{name:"Tester",run:()=>x(e)},{name:"Code Coverage",run:()=>function(e,t){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Provided code coverage data must be an object");const r=u(t);return Promise.resolve({name:"code coverage",ok:!0,results:r,reporter:L(e)})}(e,global.__mltCoverage__)},{name:"CodeCov",run:()=>j(e)}],r=new k;new G(r),r.addSteps(t);return await r.run()?0:1}export default N;
//# sourceMappingURL=mocha-lib-tester.es2015.js.map
