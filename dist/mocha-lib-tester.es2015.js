/*! @comandeer/mocha-lib-tester v0.3.0 | (c) 2021 Comandeer | MIT license (see LICENSE) */
import{ESLint as e}from"eslint";import{sync as t}from"glob";import r from"eslint/lib/cli-engine/formatters/stylish.js";import o,{reporters as n}from"mocha";import{format as s}from"util";import{resolve as i}from"path";import{addHook as c}from"pirates";import a from"@babel/register";import p from"@babel/preset-env";import{createInstrumenter as l}from"istanbul-lib-instrument";import{createCoverageMap as u}from"istanbul-lib-coverage";import m from"istanbul-lib-report";import d from"istanbul-reports";import{exec as f}from"child_process";import h from"is-ci";import g from"npm-run-path";import{Enumify as y}from"enumify";import E from"events";import w from"chalk";function b(e,t){t.log(r(e))}function v(r){if("string"!=typeof r||0===r.length)throw new TypeError("Provided path must be a non-empty string");return new e({useEslintrc:!1,cwd:r,baseConfig:{extends:"@comandeer/eslint-config"},overrideConfig:{ignorePatterns:["tests/fixtures/**/*.js"]}}).lintFiles((o=r,["src/**/*.js","bin/**/*","tests/**/*.js"].filter((e=>t(e,{cwd:o}).length>0)))).then((e=>({name:"linter",ok:C(e),results:e,reporter:b})));var o}function C(e){return e.every((({errorCount:e})=>0===e))}const{Base:R,Spec:S}=n;class T extends S{constructor(e){const t=[],r={};let o=!0;const n=R.consoleLog;R.consoleLog=function(...e){t.push(s(...e))},super(e),e.on("test end",(({file:e,state:t,title:o})=>{void 0===r[e]&&(r[e]={}),r[e][o]=t})),e.once("fail",(()=>{o=!1})),e.once("end",(()=>{R.consoleLog=n,e.suite.results={results:r,ok:o,reporter(e,r){r.log(t.join("\n"))}}}))}}function x(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");!function(e){const t=i(e,"tests"),r=i(t,"fixtures");c((e=>`import{expect}from"chai";import{use as chaiUse}from"chai";import sinon from"sinon";import chaiAsPromised from"chai-as-promised";import sinonChai from"sinon-chai";import{noCallThru as pqNoCallThru}from"proxyquire";chaiUse(chaiAsPromised),chaiUse(sinonChai);const proxyquire=pqNoCallThru();${e}`),{exts:[".js"],matcher:e=>e.startsWith(t)&&!e.startsWith(r)})}(e),a({babelrc:!1,presets:[[p,{targets:{node:"12.0.0"}}]]}),function(e){const t=i(e,"src"),r=l({coverageVariable:"__mltCoverage__"});c(((e,t)=>r.instrumentSync(e,t)),{exts:[".js"],matcher:e=>e.startsWith(t)})}(e);const r=new o({reporter:T,timeout:15e3});return t("tests/**/*.js",{cwd:e,ignore:["tests/fixtures/**/*.js","tests/helpers/**/*.js"],realpath:!0}).forEach((e=>{r.addFile(e)})),new Promise((e=>{r.run((()=>{e({name:"tester",...r.suite.results})}))}))}function L(e){return function(t){const r=m.createContext({dir:i(e,".coverage"),defaultSummarizer:"nested",watermarks:{statements:[50,80],functions:[50,80],branches:[50,80],lines:[50,80]},coverageMap:t}),o=d.create("lcovonly"),n=d.create("text");o.execute(r),n.execute(r)}}class O extends y{}O.AUTO=new O,O.BLUE=new O,O.YELLOW=new O,O.GREEN=new O,O.RED=new O,O.closeEnum();class j extends y{}function P(e,t){e.skipped?t.log("CodeCov upload skipped",{color:O.YELLOW}):(t.log(e.stdout),e.stderr&&t.log(e.stderr,{type:j.ERROR,color:O.RED}))}function k(e){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");const t={name:"codecov",reporter:P};return!h||process.env.NO_CODECOV?Object.assign({},t,{ok:!0,results:{skipped:!0}}):function(e){return new Promise((t=>{const r=f("codecov",{cwd:e,env:g.env()},((e,o,n)=>{t({exitCode:r.exitCode,stdout:o,stderr:n})}))}))}(e).then((({exitCode:e,stdout:r,stderr:o})=>Object.assign({},t,{ok:0===e,results:{stdout:r,stderr:o}})))}j.LOG=new j,j.ERROR=new j,j.closeEnum();const _=Symbol("steps");class A extends E{constructor(){super(),this[_]=Object.freeze(new Set)}get steps(){return this[_]}addStep(e){if(!U(e))throw new TypeError("Provided object must be a valid step definition");this.steps.add(e)}addSteps(e){if(!(Array.isArray(e)&&e.every((e=>U(e)))))throw new TypeError("Provided array must contain only valid step definitions");e.forEach((e=>{this.addStep(e)}))}run(){this.emit("start");const e=[...this.steps];return this._processSteps(e)}async _processSteps(e){const t=e=>(this.emit("end",e),e),r=e.shift();if(!r)return t(!0);this.emit("step:start",r);try{const o=await r.run();if(!function(e){if(!e||"object"!=typeof e)return!1;const t=e.results&&"object"==typeof e.results,r="function"==typeof e.reporter;return t&&r}(o))throw new TypeError(`Step ${r.name} didn't return correct results`);if(this.emit("step:end",r,o),!o.ok)return t(!1);if(0===e.length)return t(!0)}catch(e){return this.emit("error",e),t(!1)}return this._processSteps(e)}}function U(e){if(!e||"object"!=typeof e)return!1;const t=function(e){if("string"!=typeof e||0===e.trim().length)return!1;const t=e===e.toLowerCase(),r=!/\s/.test(e);return t&&r}(e.id),r="string"==typeof e.name&&e.name.trim().length>0,o="function"==typeof e.run;return t&&r&&o}const D=new Map([[O.AUTO,e=>e],[O.BLUE,e=>w.blue(e)],[O.YELLOW,e=>w.yellow(e)],[O.GREEN,e=>w.green(e)],[O.RED,e=>w.red(e)]]);class G{constructor(e){if(!(e instanceof E))throw new TypeError("The passed runner parameter is not an EventEmitter instance");this.runner=e,function(e){const t=e.runner;t.on("start",e.onStart.bind(e)),t.on("step:start",e.onStepStart.bind(e)),t.on("step:end",e.onStepEnd.bind(e)),t.on("end",e.onEnd.bind(e)),t.on("error",e.onError.bind(e))}(this)}log(e,{type:t=j.LOG,color:r=O.AUTO}={}){if(!(t instanceof j))throw new TypeError("Type option must be a LoggerType instance");if(!(r instanceof O))throw new TypeError("Color option must a LoggerColor instance");const o=t===j.LOG?"log":"error",n=D.get(r);console[o](n(e))}onStart(){this.log("MLT v0.3.0"),this.log("Executing testsâ€¦",{color:O.YELLOW})}onStepStart({name:e}){this.log(`---${e}---`,{color:O.BLUE})}onStepEnd({name:e},{ok:t,results:r,reporter:o}){if(o(r,this),!t)return this.log(`Step ${w.bold(e)} failed with errors. Skipping subsequent steps.`,{color:O.RED,type:j.ERROR});this.log(`Step ${w.bold(e)} finished successfully.`,{color:O.GREEN})}onEnd(e){if(!e)return this.log("There were some errors alonside the way ðŸ˜¿",{color:O.RED});this.log("All steps finished correctly ðŸŽ‰",{color:O.GREEN})}onError(e){this.log("ðŸš¨ Error occured:",{color:O.RED,type:j.ERROR}),this.log(e,{type:j.ERROR})}}async function N(e=["lint","test","coverage","codecov"]){const t=process.cwd(),r=[{id:"lint",name:"Linter",run:()=>v(t)},{id:"test",name:"Tester",run:()=>x(t)},{id:"coverage",name:"Code Coverage",run:()=>function(e,t){if("string"!=typeof e||0===e.length)throw new TypeError("Provided path must be a non-empty string");if(!t||"object"!=typeof t||Array.isArray(t))throw new TypeError("Provided code coverage data must be an object");const r=u(t);return Promise.resolve({name:"code coverage",ok:!0,results:r,reporter:L(e)})}(t,global.__mltCoverage__)},{id:"codecov",name:"CodeCov",run:()=>k(t)}],o=e.map((e=>r.find((({id:t})=>t===e))||e)),n=o.filter((e=>"string"==typeof e));if(n.length>0){const e=n.map((e=>`"${e}"`)).join(", ");throw new TypeError(`Provided step names (${e}) are incorrect`)}const s=new A;new G(s),s.addSteps(o);return await s.run()?0:1}export default N;
//# sourceMappingURL=mocha-lib-tester.es2015.js.map
